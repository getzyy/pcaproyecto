# -*- coding: utf-8 -*-
"""pcaproyecto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TfurqP-woHg2pVJtLbyIb_5RiUAZb7oY

Descargar las librerias
"""

import os
from matplotlib import pyplot as plt
from PIL import Image
import numpy as np

"""Cargar la base de datos"""

if not os.path.exists('lfwcrop_grey'):
    !wget http://conradsanderson.id.au/lfwcrop/lfwcrop_grey.zip
    !unzip 'lfwcrop_grey.zip'

filenames = []
images = []

for filename in os.listdir('lfwcrop_grey/faces'):
    filenames.append(filename)
    image = np.array(Image.open(os.path.join('lfwcrop_grey/faces', filename)))
    images.append(image)

images = np.array(images)

print('NÃºmero total de caras: {}'.format(len(images)))
print(images.shape)

X = images.reshape(13233, 64*64)
print(X.shape)

"""Visualizar la base de datos"""

plt.figure(figsize=(20, 10))
num_images = 4
for i in range(num_images):
    plt.subplot(1, num_images, i+1)
    index = np.random.choice(range(len(images)))
    image = images[index]
    filename=filenames[index]
    plt.imshow(image, 'gray')
    plt.title(filename)

"""Encontrar los eigenvectores y eigenvalores de una matriz de covarianza"""

# Sacar la matriz de covarianza (784x784)
covariance_matrix = np.cov(X.T)

# La columna de la matriz del eigenvector son los eigenvalores
eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)

"""Acomodar los eigenvalores y eigenvectores"""

# Crear un tuple de los eigenvalores y eigenvectores
# eigenvectores[:,i] usamos las columnas
eigen_pair = [(np.abs(eigenvalues[i]), eigenvectors[:,i]) for i in range(len(eigenvalues))]

# Acomodar los pares de acuerdo a los eigenvalores decrecientes
eigen_pair.sort(key=lambda x: x[0], reverse=True)

"""Seleccionar la dimension requerida para el porcentaje de varianza

Nos indica cuanta varianza puede ser atribuida para cada componente principal

los eigenvalores representan la arianza en los datos en la dimension
"""

# Porcentaje de la varianza
keep_variance=0.99

required_variance = keep_variance * sum(eigenvalues)

required_dim = 0
variance = 0
for i in range(len(eigen_pair)):
    variance += eigen_pair[i][0]
    if variance >= required_variance:
        required_dim = i + 1
        break

print('Dimension total: {}'.format(len(eigen_pair)))
print('Dimension requerida: {}'.format(required_dim))

"""Generar la matriz proyectada

la matriz contiene los eigenvectores como sus columnas
"""

projection_matrix = np.empty(shape=(X.shape[1], required_dim))

for index in range(required_dim):
    eigenvector = eigen_pair[index][1]
    projection_matrix[:, index] = eigenvector

print('Projection Matrix Shape: \n {}'.format(projection_matrix.shape))

"""Visualizar los eigen caras"""

basis = projection_matrix.reshape(64, 64, required_dim)

plt.figure(figsize=(20, 30))

for i in range(12):
    plt.subplot(4, 3, i+1)
    plt.imshow(basis[:,:,i], 'gray')
    plt.title('Template {}'.format(i+1))

"""proyectar los datos"""

projected_data = X.dot(projection_matrix)  # (13233, 577)

print(projected_data.shape)

"""visualizar los datros reconstruidos"""

import random

# indice de la image a reconstruir
index = random.randint(0,13233)

projected_image= np.expand_dims(projected_data[index], 0)  # (1, num_dims)

reconstructed_image = projected_image.dot(projection_matrix.T)  # (1, 784)
reconstructed_image = reconstructed_image.reshape(64, 64)

print('Etiqueta {}'.format(filenames[index]))
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title('Imagen original')
plt.imshow(images[index], 'gray')

plt.subplot(1, 2, 2)
plt.title('Imagen reconstruida')
plt.imshow(reconstructed_image, 'gray')

"""comparar las imagenes"""

indexes = np.array([index for index, filename in enumerate(filenames) if filename.startswith('Hans_Blix')])

# reconstruir las imagenes
projected_images = projected_data[indexes]
reconstructed_images = projected_images.dot(projection_matrix.T)  # (num_images, 784)
reconstructed_images = reconstructed_images.reshape(indexes.shape[0], 64, 64)

plt.figure(figsize=(10, 40))

for i in range(5):

    plt.subplot(5, 2, 2*i+1)
    plt.title('Original Image')
    plt.imshow(images[indexes[i]], 'gray')

    plt.subplot(5, 2, 2*i+2)
    plt.title('Reconstructed Image')
    plt.imshow(reconstructed_images[i], 'gray')